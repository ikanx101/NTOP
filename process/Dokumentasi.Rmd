---
title: "Nutrifood Transporter Routing Optimization Problem Menggunakan Spiral Dynamic Optimization Algorithm"
subtitle: | 
    | Dokumentasi Modelling dan Penyelesaian
    | Menggunakan R
author: | 
    | Departemen Market Research
    | Nutrifood Indonesia
date: "`r format(Sys.time(), '%d %B %Y')`"
fontsize: 12pt
output: 
  pdf_document:
    number_sections: true
    toc: false
    fig_width: 7
    fig_height: 4
    fig_caption: true
    highlight: tango
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyfoot[CO,CE]{Nutrifood Transporter Routing Optimization Problem}
- \fancyfoot[LE,RO]{hal \thepage}  
- \usepackage{lscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
options(scipen = 999)
rm(list=ls())

load("/cloud/project/input/data dokumentasi.rda")
```

\newpage
\tableofcontents
\newpage
\listoftables
\listoffigures
\newpage

# PENDAHULUAN

## Latar Belakang

Setiap hari, tim DTA membuat rute untuk _transporter_ mendistribusikan produk jadi ke konsumen-konsumen Nutrifood yang telah melakukan _order_. Proses ini masih dilakukan secara manual. Akibatnya proses ini memakan waktu yang cukup lama dan tidak ada kejaminan bahwa rute yang dipilih sudah optimal atau belum. Oleh karena itu, tim DTA bersama dengan tim _Digital Transformation_ dan _Market Research_ berusaha untuk membuat model optimisasi dari permasalahan ini.

## Tujuan

Membuat model optimisasi rute _transporter_ yang meminimalkan _total cost_ yang dibuat.

## Ruang Lingkup

_Business process_ yang terjadi selama ini sangat kompleks, oleh karena itu penelitian ini dibatasi pada lingkup sebagai berikut saja:

### _Business Process_ yang Hendak Dikerjakan {.unnumbered .unlisted}

Untuk mengirimkan produk jadi dari Gudang Ciawi dan Cibitung, tim DTA menyewa _transporter_ dengan berbagai jenis armada kendaraan. Masing-masing kendaraan tersebut memiliki spesifikasi yang berbeda-beda, seperti: 

1. Kapasitas maksimal kubikasi yang bisa diangkut, 
1. Kapasitas maksimal tonase yang bisa diangkut, 
1. Biaya sewa (per km). Diasumsikan biaya sewa ini nilainya tetap (tidak dipengaruhi oleh faktor lain seperti _habit_ supir dan perbedaan rute yang ditempuh), dan
1. _Loading time_. 

Masing-masing armada tersebut juga memiliki keterbatasan dari segi jumlah armada yang bisa disewa dan berapa banyak titik konsumen yang bisa dilalui.

Konsumen memesan (melalui proses _purchase order_ - PO) sejumlah produk jadi kepada Nutrifood. Pada PO tersebut, kita memiliki informasi sebagai berikut:

1. Berapa total kubik dan tonase produk yang harus dikirim. 
1. _Range_ tanggal pengiriman produk. 

Nutrifood harus memenuhi pembelian tersebut secara langsung (tidak boleh memecah pengiriman produk dalam satu PO menjadi beberapa kali pengiriman). Masing-masing konsumen akan dilayani oleh gudang Ciawi atau Cibitung sesuai dengan pembagian yang telah ditetapkan sebelumnya. Tidak ada konsumen yang dilayani oleh keduanya.

Masing-masing konsumen memiliki keterbatas lain terkait armada yang bisa dilalui karena lokasi mereka berbeda-beda. Ada konsumen yang berlokasi di jalan besar sehingga armada ukuran besar bisa melewatinya dengan aman. Namun ada beberapa konsumen yang lokasinya hanya bisa dilalui oleh armada kecil.

## Metode Penyelesaian Model Optimisasi

Untuk menyelesaikan model optimisasi ini, saya akan menggunakan pendekatan _meta heuristic_ dibandingkan penyelesaian secara _exact_. Berikut alasannya:

1. Kita tidak perlu menuliskan model matematika yang kompleks karena permasalahan yang kita hadapi ini memiliki indeks yang tinggi. Kita cukup menuliskan algoritma (_computational model_) berdasarkan definisi dan _constraints_ secara logis.
1. Penyelesaian dengan metode _exact_ memang menjamin keoptimalan solusi namun tidak semua model bisa dicari solusinya. Sedangkan penyelesaian dengan metode _meta heuristic_, tidak menjamin solusi yang didapatkan adalah solusi yang paling optimal. Namun kita bisa menjadikan solusi tersebut _near optimal_ dengan melakukan _tweaking_ pada algoritma.

Pendekatan _meta heuristic_ yang akan saya gunakan adalah _Spiral Dynamic Optimization Algorithm_.

\newpage

# SDOA

## Penjelasan Singkat

_Spiral Dynamic Optimization Algorithm_ (SDOA) adalah salah satu metode _meta heuristic_ yang digunakan untuk mencari minimum global dari suatu sistem persamaan. 

Algoritmanya mudah dipahami dan intuitif tanpa harus memiliki latar keilmuan tertentu. Proses kerjanya adalah dengan melakukan _random number generating_ pada suatu selang dan melakukan rotasi sekaligus kontraksi dengan titik paling minimum pada setiap iterasi sebagai pusatnya.

Berikut adalah algoritmanya:

```
INPUT
  m >= 2 # jumlah titik
  theta  # sudut rotasi (0 <= theta <= 2pi)
  r      # konstraksi
  k_max  # iterasi maksimum
PROCESS
  1 generate m buah titik secara acak
      x_i
  2 initial condition
      k = 0 # untuk keperluan iterasi
  3 cari x_* yang memenuhi
      min(f(x_*))
  
  4 lakukan rotasi dan konstraksi semua x_i
      x_* sebagai pusat rotasi
      k = k + 1
  5 ulangi proses 3 dan 4
  6 hentikan proses saat k = k_max
      output x_*
```

Berdasarkan algoritma di atas, salah satu proses yang penting adalah melakukan __rotasi__ dan __konstraksi__ terhadap semua titik yang telah di-_generate_.

## Menyelesaikan Masalah Optimisasi dengan SDOA

Misal suatu permasalahan MILP atau MINLP bisa ditulis secara umum sebagai berikut:

$$\min_{x \in \mathbb{R}^n} f(x)$$

$$\text{subject to: } g_i(x) = 0, i = 1,2,..,M$$

$$\text{and } h_j(x) \leq 0,i = 1,2,..,N$$

$$x = (x_1,x_2,...,x_n)^T \in \mathbb{N}$$

Bentuk di atas bisa kita ubah menjadi:

$$F(x,\alpha,\beta) = f(x) + \sum_{i=1}^M \alpha_i g_i^2(x) + \sum_{j = 1}^N \beta_j (\max{(h_i(x),0)})^2$$

dimana $\alpha,\beta$ merupakan _penalty constant_ yang bisa dibuat sangat besar.

## Matriks Rotasi untuk n-Dimensi

SOA relatif mudah untuk dituliskan dalam bentuk algoritma bahasa pemrograman manapun. Tapi ada satu hal yang bisa menjadi batu ganjalan dalam menuliskan algoritmanya. Apa itu? Yaitu pendefinisian matriks rotasi untuk masalah dengan n-dimensi.

Bentuk umum dari matriks rotasi adalah sebagai berikut:

$$R^{(n)} (\theta_{1,2},\theta_{1,3},..,\theta_{n,n-1}) = \prod_{i=1}^{n-1} \left ( \prod_{j=1}^i R^{(n)}_{n-i,n+1-j} (\theta_{n-i,n+1-j}) \right )$$

Perhatikan bahwa perkalian matriks rotasi yang dilakukan adalah _cross product_.

Alasan: Rotasi tidak mengubah _norm_ suatu vektor.

\newpage

# DATA TERKAIT

Data _real_ dari DTA dan gudang sedang disusun oleh tim terkait. Oleh karena itu, saya akan gunakan data _dummy_ berdasarkan informasi pada bagian sebelumnya.

## Data Terkait _Order_ Toko

```{r,echo=FALSE,message=FALSE}
df_order %>% knitr::kable(caption = "Data Order Toko")
```

Penjelasan terkait variabel dari tabel di atas:

1. `nama_toko`, yakni nama-nama toko yang melakukan _order_ produk ke Nutrifood.
1. `order_kubikasi`, yakni berapa total kubik produk yang dipesan. Satuan yang digunakan adalah $m^2$.
1. `order_tonase`, yakni berapa total kilogram produk yang dipesan.
1. `tanggal_kirim_min`, yakni tanggal berapa produk sudah bisa dikirim.
1. `tanggal_kirim_max`, yakni tanggal berapa produk paling lambat harus dikirim.

## Data Terkait Informasi Detail Toko

```{r,echo=FALSE,message=FALSE}
df_toko %>% knitr::kable(caption = "Data Informasi Toko")
```

Penjelasan terkait variabel dari tabel di atas:

1. `nama_toko`, yakni nama-nama toko yang melakukan _order_ produk ke Nutrifood.
1. `long`, yakni _longitude_ dari alamat toko.
1. `lat`, yakni _latitude_ dari alamat toko.
1. `max_armada`, yakni jenis armada terbesar yang bisa masuk ke toko. Misalkan, jika `max_armada = 2`, artinya toko tersebut bisa dilalui armada jenis `1` dan `2`.
1. `supplied`, yakni gudang yang men-_supply_ toko tersebut.

## Data Terkait Gudang

```{r,echo=FALSE,message=FALSE}
df_gudang %>% knitr::kable(caption = "Data Time Slot Gudang")
```


Penjelasan terkait variabel pada tabel di atas:

1. `site`, jenis gudang: Ciawi atau Cibitung.
1. `week_day_hour`, total waktu kerja yang tersedia pada hari kerja untuk melakukan _loading_ produk dari gudang ke armada. Satuan dari data ini adalah dalam jam.
1. `week_end_hour`, total waktu kerja yang tersedia pada hari libur untuk melakukan _loading_ produk dari gudang ke armada. Satuan dari data ini adalah dalam jam.

Kedua data total waktu kerja ini berdasarkn jam kerja pada dua _shift_.

\newpage
\blandscape

## Data Terkait Armada

```{r,echo=FALSE,message=FALSE}
df_jenis_armada %>% knitr::kable(caption = "Data Informasi Armada")
```

Penjelasan terkait variabel dari tabel di atas:

1. `armada`, yakni jenis armada yang bisa disewa Nutrifood.
1. `max_cap_kubikasi`, yakni kapasitas maksimum kubikasi yang bisa diangkut oleh armada tersebut. Satuan dari data ini $m^2$.
1. `max_cap_tonase`, yakni kapasitas maksimum berat barang yang bisa diangkut oleh armada tersebut. Satuan dari data ini $kg$.
1. `cost_per_km`, yakni berapa biaya sewa mobil per kilometer untuk mobil tersebut. Satuan dari data ini $Rp$. Informasi dari tim DTA:
    - Secara _real_, nilainya berbeda-beda tergantung _provider_ yang digunakan walau jenis mobilnya sama.
    - Hal ini terjadi karena perbedaan _habit_ mengemudi para _driver_ dan rute yang diambil.
    - Oleh karena itu, pada kasus ini, nilainya kita asumsikan sama karena tidak ada kepastian _provider_ mana yang akan tersedia pada hari pengiriman tersebut.
1. `tersedia`, yakni berapa banyak armada tersebut tersedia untuk disewa. Informasi dari tim DTA:
    - Pada kondisi _real_, tidak ada pembatasan berapa banyak armada yang tersedia. Bisa diasumsikan nilainya _unlimited_.
    - Namun, ada baiknya jika kita masukan parameter batas ini untuk mengakomodir kebutuhan di kemudian hari.
    - Untuk keperluan komputasi, ketersediaan ini tidak saya jadikan parameter pada model, tapi digunakan untuk mereplikasi baris data pada tabel di atas.
1. `max_titik`, yakni berapa banyak maksimal konsumen yang pesanannya bisa diantar.
1. `loading_time`, yakni berapa lama proses _loading_ yang dibutuhkan untuk masing-masing armmada di gudang Ciawi atau Cibitung. Satuan dari data ini adalah jam.

\elandscape

\newpage

# _MATHEMATICAL MODEL_

Menuliskan model matematika dari permasalahan kompleks di atas menjadi tantangan tersendiri karena variabel yang terlibat akan memiliki indeks yang tinggi, setidaknya ada 4 indeks yang berasal dari 4 himpunan yang terlibat:

## _Index_ dan Himpunan yang Terlibat

- $\mathcal{T} = \{1,2,..,t\}$ sebagai himpunan toko yang memesan produk ke Nutrifood.
- $\mathcal{M} = \{ 1,2,..,m\}$ sebagai himpunan jenis armada yang bisa disewa Nutrifood.
- $\mathcal{G} = \{1,2\}$ sebagai himpunan gudang yang men-_supply_ semua toko yang ada.
- $\mathcal{D} = \{1,2,..,d\}$ sebagai himpunan tanggal pengiriman produk dari Nutrifood ke toko.
    - $\mathcal{\hat{D}}$ sebagai hari _weekday_.
    - $\mathcal{\dot{D}}$ sebagai hari _weekend_.
    

## Parameter dari Data

Tuliskan:

- $ok_{t}, t \in \mathcal{T}$ sebagai _order_ kubikasi toko $t$.
- $ot_{t}, t \in \mathcal{T}$ sebagai _order_ tonase toko $t$.
- $\forall t \in \mathcal{T}, tgl1_t$ sebagai tanggal minimal pengiriman produk oleh Nutrifood untuk toko $t$.
- $\forall t \in \mathcal{T}, tgl2_t$ sebagai tanggal maksimal pengiriman produk oleh Nutrifood untuk toko $t$.
- $\forall t_1,t_2 \in \mathcal{T}, J_{t_1 t_2}$ sebagai jarak antara toko $t_1$ dan toko $t_2$.
- $\forall m \in \mathcal{M}, maxcap1_m$ sebagai max kapasitas kubikasi yang bisa diangkut armada $m$.
- $\forall m \in \mathcal{M}, maxcap2_m$ sebagai max kapasitas tonase yang bisa diangkut armada $m$.
- $\forall m \in \mathcal{M}, cost_m$ sebagai biaya sewa perkilometer armada $m$.
- $\forall m \in \mathcal{M}, temp_m$ sebagai max banyaknya toko yang bisa diantarkan armada $m$.
- $\forall m \in \mathcal{M}, lt_m$ sebagai _loading time_ armada $m$.
- $\forall g \in \mathcal{G}, ts1_g$ sebagai total _time slot_ gudang $g$ pada _weekday_.
- $\forall g \in \mathcal{G}, ts2_g$ sebagai total _time slot_ gudang $g$ pada _weekend_.

Dari _sets_ dan parameter di atas, kita akan buat _computational model_-nya sebagai berikut.

\newpage

# _COMPUTATIONAL MODEL_

Untuk membuat model komputasinya, kita buat terlebih dahulu beberapa _function_ dasar berikut ini:

## _Function_ Dasar

Berikut adalah beberapa _function_ dasar yang akan digunakan pada SDOA.

### _Rotation Matrix_

Ini adalah _function_ untuk membuat matriks rotasi:

```{r,message=FALSE,warning=FALSE}
# function matriks rotasi
buat_rot_mat = function(theta,n){
  # buat template sebuah matriks identitas
  temp_mat = matrix(0,ncol = n,nrow = n)
  diag(temp_mat) = 1
  
  # buat matriks identitas terlebih dahulu
  mat_rot = temp_mat
  # membuat isi matriks rotasi
  for(i in 1:(n-1)){
    for(j in 1:i){
      temp = temp_mat
      idx = n-i
      idy = n+1-j
      # print(paste0("Matriks rotasi untuk ",idx," - ",idy,": DONE"))
      temp[idx,idx] = cos(theta)
      temp[idx,idy] = -sin(theta)
      temp[idy,idx] = sin(theta)
      temp[idy,idy] = cos(theta)
      # assign(paste0("M",idx,idy),temp)
      mat_rot = mat_rot %*% temp
      mat_rot = mat_rot 
    }
  }
  # output matriks rotasi
  return(mat_rot)
}

```

\newpage

### _Generator_ Calon Solusi

Kelak calon solusi yang diharapkan memiliki format sebagai berikut:

```{r,message=FALSE,warning=FALSE,echo=FALSE}
df_order %>%
  mutate(armada_kirim  = sample(5,20,replace = T)) %>% 
  rowwise() %>% 
  mutate(tanggal_kirim = sample(tanggal_kirim_min:tanggal_kirim_max,1)) %>% 
  ungroup() %>% 
  select(-tanggal_kirim_max,
         -tanggal_kirim_min) %>% 
  knitr::kable(caption = "Calon Solusi yang Diharapkan")
```


Oleh karena itu, solusi yang perlu di-_generate_ ada dua variabel:

1. `armada_kirim`, yakni armada yang digunakan untuk mengirimkan pesanan toko.
1. `tanggal_kirim`, yakni tanggal pesanan toko dikirim.

Berikut adalah _function_ _generator_-nya:

```{r,message=FALSE,warning=FALSE}
# generate solusi untuk armada
armada_generate = function(n_toko,n_armada){
  sample(n_armada,n_toko,replace = T)
}

# generate tanggal kirim sesuai dengan data yang ada pada df_order
tanggal_generate = function(var,df){
  hasil = rep(0,n_toko)
  min   = df[["tanggal_kirim_min"]] %>% as.numeric()
  max   = df[["tanggal_kirim_max"]] %>% as.numeric()
  for(i in 1:n_toko){
    if(min[i] == max[i]){
      hasil[i] = min[i]
    }
    if(min[i] != max[i]){
      hasil[i] = sample(c(min[i]:max[i]),1)
    }
  }
  return(hasil)
}
```


### Menghitung Matriks Jarak

Berikut adalah _function_ untuk matriks jarak:

```{r,message=FALSE,warning=FALSE}
# function untuk membuat matriks jarak
buat_matriks_jarak = function(df){
  n_toko = nrow(df)
  # buat rumahnya terlebih dahulu
  dist_mat = matrix(0,n_toko,n_toko)
  # kita buat euclidean distance terlebih dahulu
  hitung_jarak = function(i,j){
    lon_hit = df$long[i] - df$long[j]
    lat_hit = df$lat[i] - df$lat[j]
    jarak = sqrt(lon_hit^2 + lat_hit^2)
    round(jarak,3)
  }
  # kita hitung jaraknya sekarang
  for(i in 1:n_toko){
    for(j in 1:n_toko){
      dist_mat[i,j] = hitung_jarak(i,j)
    }
  }
  # hasil finalnya
  return(dist_mat)
}
```


### Menghitung Panjang Rute Optimal

Berikut adalah _function_ untuk menghitung panjang rute optimal dari _input_ berupa _database_ toko:

```{r,message=FALSE,warning=FALSE}
# perhitungan rute optimal
# inputnya adalah matriks jarak
tsp_hitung = function(new){
  # jangan lupa new adalah df_toko yang sudah di-slice
  jarse = buat_matriks_jarak(new)
  problem = as.ATSP(jarse)
  hasil = solve_TSP(problem)
  level = row.names(new)
  panjang_rute = tour_length(hasil)
  detail_rute  = paste(level[as.integer(hasil_1)],collapse = " - ")
  return(panjang_rute)
}
```


## _Constraints_

Berikut adalah beberapa _constraints_ pada permasalahan ini:

## Objective Function















